まずはDDDを意識しよう
共通を見つけたらclassに抽出
use caseのclassを見つける
database tableとは別
//テーブル情報をclassにするアプローチもある==>branch master


//記録ID
class PgPerfRecordId //entity
{
    private $id; //int=serialNo
    private $pgPerfRecordDate; //PgPerfRecordDate
    
    //共通
    public function equals(PgPerfRecordId $id):bool
    {
    }
    
    //共通
    //getter id,pgPerfRecordDate
    
    
}

//記録日
class PgPerfRecordDate //valueObject=immutable
{
    private $data;  //DateTimeInterface
    
    //共通
    public function format(string $format):string
    {
    }
    
    //getter
    
}

//データベースサイズ usecase class/aggrigate チャートに使うクラス
class DatabaseSize
{
    private $databaseId;
    private $pgPerfRecordId;
    private $size;  //file size class
    
    //getter
    //共通
    //toArray
    
}

//ファイルサイズは1024B/1000B区切りで異なる
class FileSize //extends/implements Number ==>python Number参照 valueObject
{
    const public GOOD_PLACE = 1000;
    const public BAD_PLACE = 1024;
    
    
    private $data;
    private $baseUnit;  //基数1024/1000
    
    public function __construct(int $data, $baseUnit = FileSize::BAD_PLACE):FileSize
    {
        
        
        
    }
    
    
    //基数を考慮して
   public function add(FileSize $fileSize, $baseUnit = FileSize::BAD_PLACE):FileSize
    {
        
        
        
        
        return new FileSize($data, $baseUnit);
    }
   
    //getter data,baseUnit
    //get数値
    
}

//データベース識別
classDatabaseId //entity
{
    private $id;    //postgresとかtemplate0,userTable1...
    
    
}

//テーブルレコード数?　usecase class/aggrigate チャートに使うクラス
{
    private $databaseId;
    private $pgPerfRecordId;
    private $tableId;
    private $rowCount;  //int
    
}



//テーブル識別
class TableId
{
    private $id; //public.mst_tanto
    
    
}


////////////////////////
//別に、mutatorを特別扱いしなくても良いのでは
//始めからmutator


trait GetAccessor
{
    protected $getProperties = [];
    
    public function __get($name)
    {
        if (property_exists($this, $name)
            && in_array($name, $this->getProperties)
        {
            return $this->$name;
        }    
        throw new InvalidArgumentException(
            "not defined:{$name}"
        );
    }
}

//mutateを追加したい
//casts==>型変換も欲しい
//getに入れる
//acsessorはDBとのやりとりに?

trait GetAccessMutator
{
    protected $getProperties = [];
    protected $casts = [];
    
    public function __get($name)
    {
        $method = 'get' . mb_convert_case($name, MB_CASE_TITLE);
        if (method_exists($this, $method)) {
            return $this->$method();
        }
        
        if (!property_exists($this, $name)
            || in_array($name, $this->getProperties)
        ) {
            throw new InvalidArgumentException(
                "not defined:{$name}"
            );
        }
        
        if (array_key_exists($name, $this->casts)) {
            return $this->casts($name);
        }
        return $this->$name;
    }
    
    protected function cast(string $name)
    {
        switch ($this->casts[$name]) {
            case 'bool':
                return (bool)$this->$name;
            case 'int':
                return (int)$this->$name;
            case 'float':
                return (float)$this->$name;
            case 'string':
                return (string)$this->$name;
                
                
                //フォーマット指定あり・なし
                date:Y-m-d
                datetime:Y-m-d H:i:s
                time:His
                
                //どうする？
                object
                array
                json
                
            
            
            
            
            default:
                throw new InvalidArgumentException(
                    "definition is wrong:{$name}"
                );
        }
    }
}


//以下set accessorは（要修正）

trait SetAccessor
{
    protected $setProperties = [];
    
    public function __set($name, $value)
    {
        //getterと同じように先に存在しないを判定（要修正）
        if (property_exists($this, $name)
            && in_array($name, $this->setProperties)
        {
            $this->$name = $value;
        }    
        throw new InvalidArgumentException(
            "not defined:{$name}"
        );
    }
}

trait SetAccessMutator
{
    protected $setProperties = [];
    
    public function __set($name)
    {
        $method = 'set' . mb_convert_case($name, MB_CASE_TITLE);
        if (method_exists($this, $method) {
            $this->$method($value);
        }
        
        //getterと同じように先に存在しないを判定（要修正）
        if (property_exists($this, $name)
            && in_array($name, $this->setProperties)
        {
            $this->$name = $value;
        }    
        throw new InvalidArgumentException(
            "not defined:{$name}"
        );
    }
}

///////////////////////////


//accessorとは別に、上記ドメインobjではsetter/getterの方が良いのでは?

trait PropertyAccessor
{
    protected $gettors = [];
    protected $settors = [];
    
    publif cunction __call($name, array $arg)
    {
        $type = mb_substr($name, 0, 3);
        $name = mb_substr($name, 3);
        
        if ($type == 'get'
            && in_array($name, $this->gettors)
            && property_exists($this, $name)
        ) {
            return $this->$name;
        }
        
        if ($type == 'set'
            && in_array($name, $this->settors)
            && property_exists($this, $name)
        ) {
            $this->$name = $arg;
            return $this;
        }
        throw new BadMethodCallException(
            "not defined:{$name}"
        );
    }
}





